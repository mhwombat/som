------------------------------------------------------------------------
-- |
-- Module      :  Data.Datamining.Clustering.SOMQC
-- Copyright   :  (c) Amy de Buitléir 2012-2013
-- License     :  BSD-style
-- Maintainer  :  amy@nualeargais.ie
-- Stability   :  experimental
-- Portability :  portable
--
-- Tests
--
------------------------------------------------------------------------
{-# LANGUAGE UnicodeSyntax, MultiParamTypeClasses, TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-type-defaults -fno-warn-orphans #-}

module Data.Datamining.Clustering.SOM.ClassifierQC
  (
    test
  ) where

import Data.Datamining.Clustering.SOM.Classifier
import Data.Datamining.Clustering.SOMQC hiding (test)

import Data.Eq.Unicode ((≡), (≠))
import Data.List (sort)
import Math.Geometry.Grid (Grid, HexHexGrid, hexHexGrid, tileCount)
import Math.Geometry.GridMap ((!), GridMap)
import Math.Geometry.GridMap.Lazy (LGridMap)
import Test.Framework as TF (Test, testGroup)
import Test.Framework.Providers.QuickCheck2 (testProperty)
import Test.QuickCheck ((==>), Gen, Arbitrary, arbitrary, choose, 
  Property, property, sized, vectorOf)

instance (Show (gm p)) ⇒ Show (Classifier gm p) where
  show c = "Classifier " ++ show (cSOM c) ++ " <function> " ++ 
              show (cCounter c)

data ClassifierAndTargets = ClassifierAndTargets 
  (Classifier (LGridMap HexHexGrid) Double) [Double] 
    deriving Show

-- | Generate a classifier and a training set. The training set will 
--   consist @j@ vectors of equal length, where @j@ is the number of 
--   patterns the classifier can model. After running through the 
--   training set a few times, the classifier should be very accurate at
--   identifying any of those @j@ vectors.
sizedClassifierAndTargets ∷ Int → Gen ClassifierAndTargets
sizedClassifierAndTargets n = do
  sideLength ← choose (1, min (n+1) 5) --avoid long tests
  let g = hexHexGrid sideLength
  let numberOfPatterns = tileCount g
  ps ← vectorOf numberOfPatterns arbitrary
  r ← choose (0, 1)
  w0 ← choose (0, 2)
  tMax ← choose (0, 10)
  let f = decayingGaussian r w0 tMax
  let c = buildClassifier g ps f
  targets ← vectorOf numberOfPatterns arbitrary
  return $ ClassifierAndTargets c targets
  
instance Arbitrary ClassifierAndTargets where
  arbitrary = sized sizedClassifierAndTargets

-- | If we use a fixed learning rate of one (regardless of the distance
--   from the BMU), and train a classifier once on one pattern, then all
--   nodes should match the input vector.
prop_global_instant_training_works ∷ ClassifierAndTargets → Property
prop_global_instant_training_works (ClassifierAndTargets c xs) = 
  property $ models c' `approxEqual` replicate (numModels c) x
    where x = head xs
          c' = train c x

prop_training_works ∷ ClassifierAndTargets → Property
prop_training_works (ClassifierAndTargets c xs) = errBefore ≠ 0 ==>
  errAfter < errBefore
    where (bmu, c') = classifyAndTrain c x
          x = head xs
          errBefore = abs (x - (toGridMap c) ! bmu)
          errAfter = abs (x - (toGridMap c') ! bmu)

--   Invoking @diffAndTrain f c p@ should give identical results to
--   @(p `classify` c, train c f p)@.
prop_classifyAndTrainEquiv ∷ ClassifierAndTargets → Property
prop_classifyAndTrainEquiv (ClassifierAndTargets c ps) = property $
  bmu ≡ c `classify` p && toGridMap c1 ≡ toGridMap c2
    where p = head ps
          (bmu, c1) = classifyAndTrain c p
          c2 = train c p         

--   Invoking @diffAndTrain f c p@ should give identical results to
--   @(c `diff` p, train c f p)@.
prop_diffAndTrainEquiv ∷ ClassifierAndTargets → Property
prop_diffAndTrainEquiv (ClassifierAndTargets c ps) = property $
  diffs ≡ c `diff` p && toGridMap c1 ≡ toGridMap c2
    where p = head ps
          (diffs, c1) = diffAndTrain c p
          c2 = train c p

-- | The training set consists of the same vectors in the same order, 
--   several times over. So the resulting classifications should consist
--   of the same integers in the same order, over and over.
prop_batch_training_works ∷ ClassifierAndTargets → Property
prop_batch_training_works (ClassifierAndTargets c xs) = property $
  classifications ≡ (concat . replicate 5) firstSet 
  where trainingSet = (concat . replicate 5) xs
        c' = trainBatch c trainingSet
        classifications = map (classify c') trainingSet
        firstSet = take (length xs) classifications

-- | If we train a classifier once on a set of patterns, where the 
--   number of patterns in the set is equal to the number of nodes in
--   the classifier, then the classifier should become a better 
--   representation of the training set. The training set is designed to
--   reduce the possibility that a single node will train to more than
--   one pattern (which would render the test invalid).
prop_batch_training_works2 ∷ ClassifierAndTargets → Property
prop_batch_training_works2 (ClassifierAndTargets c _) = 
  errBefore ≠ 0 ==> errAfter < errBefore
    where c' = trainBatch c xs
          xs = take (numModels c) [0,100..]
          errBefore = euclideanDistanceSquared (sort xs) (sort (models c))
          errAfter = euclideanDistanceSquared (sort xs) (sort (models c'))

test ∷ Test
test = testGroup "QuickCheck Data.Datamining.Clustering.SOM.ClassifierQC"
  [
    testProperty "prop_global_instant_training_works"
      prop_global_instant_training_works,
    testProperty "prop_training_works" prop_training_works,
    testProperty "prop_classifyAndTrainEquiv"
      prop_classifyAndTrainEquiv,
    testProperty "prop_diffAndTrainEquiv" prop_diffAndTrainEquiv,
    testProperty "prop_batch_training_works" prop_batch_training_works,
    testProperty "prop_batch_training_works2"
      prop_batch_training_works2
  ]

